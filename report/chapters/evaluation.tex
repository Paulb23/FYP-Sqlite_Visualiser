%
% The MIT License (MIT)
%
% Copyright (c) 2016 Paul Batty
%
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
%
% The above copyright notice and this permission notice shall be included in
% all copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
% THE SOFTWARE.
%

\section{Evaluation}
\label{sec:evaluation}

Now that the paper is coming to and end, this section will reflect on the final results from this project, and whether the final results have met our overall aims. Including the design principles used through the undertaking of the project.

\subsection{Design principles}
\label{subsec:design_principles}

During the project the overall design and structure keep as close to good OOP (Object orientated programming) paradigms and designs as possible. As stated in the introduction the main aim was to build tool that anyone could use to debug their own databases, with the five main features visualisation, command logging, live updating, executing SQL and browsing data. Wrapped up within a user interface. 
\\\\
With support for other database system when needed, just by extending the interfaces and providing an implementation. In addition to sticking to good OOP design, TDD (Test driven development) was used in order to make sure that the final application, would work under a variety of circumstances. In the end theses aims where achieved. With the exception, of the lock byte and pointer map pages, as stated towards the start of the paper. 
\\\\
Firstly, with the exception of the Log, all of the implemented features worked as planned. The log however, originally was going to report the SQL commands sent to the database, but as seen in the last chapter due to the nature of SQLite this became very hard to do. in order to get around this the final system could only report the changes that have occurred.

\subsection{The System}
\label{subsec:system_eval}

The system architecture, works efficiently and follows a modular pattern making it adaptable to other systems, should the need arise. The modularisation, however, has caused some issues during development, as mentioned during the implementation section with the live updater. Having to move around, and adapt the modules to become disconnected from one and another. Doing so made it harder to implement some of the features. But, in the long run will end up creating a better and more robust application.
\\\\
Although the application is built in Java it does not suffer any performance consequences on smaller databases as a result of this. Passing the larger database, using Java's nanosecond timer, takes on average  154.1 milliseconds to parse. While this may not seen like a long time if it is scaled it up to a few megabytes the parsing could potentially be an issue. 
\\\\
In addition to the performance scaling, there were a few feature that did not get added to the final application that would have enhanced it. Including the table exporter, to CSV, XML and JSon, a log exporter, and the ability to modify the database without having to use SQL, just by editing the values shown in the interface. In addition to this enhancing the SQL editor, by providing  auto complete and syntax highlighting, to further improve the user experience. Lastly, the table view should be able to collect the data from the snapshot rather then the database file. This would have enabled users to browser the data at a specific time slot easier, rather then having to inspect the nodes within the visualiser.  Most of theses features were left out due to time constraints. 

\subsection{User interface}
\label{subsec:user_interface_eval}

The overall user interface, looks clean and follows the standard layout seen in many other application. With the menu bar located at the top and the content underneath. This makes it intuitive and easy to pick up. With that said, support for a more customisable experience would enhance the experience, such as themes, text size and font type.
\\\\
In addition to allowing the user to customise the interface, the application would also benefit by improving the visualisation, to allow collapsible nodes, and have the nodes better represent what it contains, either as a minimised preview, or icons, rather then using colour coding.
\\\\
Along side the visualiser, other aspects of the user interface could be polished up to make the overall experience enjoyable. Such as disabling the time line control buttons when they cannot move along the time line in that direction. Zooming to the mouse pointer position on the visualiser rather then always to the top left. Lastly, allowing the section to be popped out of the main window frame, allowing them to be dragged around separately. 
\\\\
Although theses changes do not affect the application drastically, they are complementary to the entire experience. As stated towards the start of this paper, the tool should be accessible to everyone. In order to accomplish this the application should be easy and enjoyable to use. By implementing the above user interface enhancements, the user experience and ease of use will increase alongside it, opening the application up to more users.
 
\subsection{Usage}
\label{subsec:usage_eval}

The final system, has the distinct advantage over many over application of showing you how the SQLite file is laid out. In addition to the visualisation it can also show you changes from every single connection and command ran onto the database, something previously impossible. This allows the application to be used is a multitude of different ways.
\\\\
Firstly, the application can be used within or for educational purposes to teach and under stand how SQLite works internally, as the user can see the database grow an shrink. This can then be generalised further to show how database systems use B-Trees. 
\\\\
Secondly, the application could be used as a tool to aid the debugging process of SQLite, and as a log. This would allow users to track changes and see any anomalies that occur, in both the file format, such as missing tables or corrupt databases. The log would allow users to record the activities with in database, allowing detection of tables for optimisation, or detecting malicious activities.
\\\\
The last usage coved here is as a replacement user interface for SQLite as stated towards the start of this paper. With the combined features and user interface enhancement mentioned above this tool could replace the current applications used for SQLite. 